# solidityQuestions
This repo contains a collection of basic and intermediate Solidity coding questions, culled from various AI paradigms such as ChatGPT, Bard AI, and Phind AI. The questions are designed to help you build a solid foundation in Solidity and gain the skills needed to create smart contracts and also help beginners in smart contract development to develop an basic understanding..

### ```  ✅   answered question  ❌ pending questions```

## QUESTIONS


```  ✅ ```1. Write a Solidity contract that stores a single number. Include a function to update this number.

```  ✅ ```2. Create a contract that stores an address. Include a function to update this address. 

```  ✅ ```3. Write a contract that stores a string. Include a function to update this string.  

```  ✅ ```4.Create a contract that stores an array of numbers. Include functions to add and remove numbers from this array.

```  ✅ ```5.Write a contract that stores a mapping from addresses to numbers. Include functions to update this mapping.

```  ✅ ```6.Create a contract that includes a payable function. This function should update a stored number based on the amount of Ether sent.

```  ✅ ```7.Write a contract that emits an event. Include a function that triggers this event.

```  ✅ ```8.Create a contract that includes a modifier. Use this modifier in a function.

```  ✅ ```9.Write a contract that inherits from another contract. Include a function in the child contract that overrides a function in the parent contract.

10.Create a contract that interacts with another contract. Include a function in the first contract that calls a function in the second contract.

```  ✅ ```11.Write a contract that uses a struct to store information about a person (name, age, and address).

12.Create a contract that uses an enum to represent different states of a process.

```  ✅ ```13.Write a contract that includes a constructor function.

14.Create a contract that includes a fallback function.

15.Write a contract that uses the now keyword to get the current timestamp.

```  ✅ ```16.Create a contract that uses the msg.sender keyword to get the address of the person calling a function.

```  ✅ ```17.Write a contract that uses the msg.value keyword to get the amount of Ether sent with a function call.

18.Create a contract that uses the this keyword to refer to the contract itself.

19.Write a contract that uses the new keyword to create a new contract.

20.Create a contract that uses the delete keyword to reset a variable to its initial state.

21.Write a contract that uses the assert function to check invariants.

22.Create a contract that uses the require function to check inputs and conditions.

23.Write a contract that uses the revert function to revert state changes.

24.Create a contract that uses the keccak256 function to hash a value.

25.Write a contract that uses the ecrecover function to recover the address associated with a digital signature.

26.Create a contract that uses the selfdestruct function to destroy the contract and send its funds to an address.

```  ✅ ```27.Write a contract that uses the block.timestamp property to get the current block timestamp.

```  ✅ ```28.Create a contract that uses the block.number property to get the current block number.

29.Write a contract that uses the block.difficulty property to get the current block difficulty.

30.Create a contract that uses the block.coinbase property to get the current block miner’s address.

31.Write a contract that uses the gasleft function to get the remaining gas.

32.Create a contract that uses the tx.origin property to get the original sender of the transaction.

33.Write a contract that uses the tx.gasprice property to get the gas price of the transaction.

34.Create a contract that uses the abi.encode function to ABI-encode values.

35.Write a contract that uses the abi.decode function to ABI-decode values.

36.Create a contract that uses the abi.encodePacked function to ABI-encode values with packed encoding.

37.Write a contract that uses the abi.encodeWithSignature function to ABI-encode values with a function signature.

38.Create a contract that uses the address.balance property to get the balance of an address.

39.Write a contract that uses the address.transfer function to send Ether to an address.

40.Create a contract that uses the address.call function to call a function on another contract.

41.Write a contract that uses the address.delegatecall function to delegate a call to another contract.

42.Create a contract that uses the address.staticcall function to make a read-only call to another contract.

43.Write a contract that uses the address.payable function to convert an address to a payable address.

44.Create a contract that uses the bytes.length property to get the length of a bytes array

45.Write a contract that uses the bytes.concat function to concatenate two bytes arrays.

46.Create a contract that uses the bytes32.byte property to get a specific byte in a bytes32 value.

47.Write a contract that uses the bytes32.leftPadded function to left-pad a bytes32 value.

48.Create a contract that uses the bytes32.rightPadded function to right-pad a bytes32 value.

49.Write a contract that uses the int.min property to get the minimum value of an integer type.

50.Create a contract that uses the int.max property to get the maximum value of an integer type.

51.Write a contract that uses the uint.min property to get the minimum value of an unsigned integer type.

52.Create a contract that uses the uint.max property to get the maximum value of an unsigned integer type.

53.Write a contract that uses the array.push function to add an element to an array.

54.Create a contract that uses the array.pop function to remove an element from an array.

55.Write a contract that uses the array.length property to get the length of an array.

56.Create a contract that uses the array[0] syntax to access an element in an array.

57.Write a contract that uses the mapping[key] syntax to access a value in a mapping.

```  ✅ ```58.Create a contract that uses the for keyword to create a loop.

```  ✅ ```59.Write a contract that uses the if keyword to create a conditional statement.

```  ✅ ```60.Create a contract that uses the else keyword to create an alternative branch in a conditional statement.

```  ✅ ```61.Write a contract that uses the while keyword to create a loop.

62.Create a contract that uses the do keyword to create a loop.

```  ✅ ```63.Write a contract that uses the break keyword to exit a loop.

```  ✅ ```64.Create a contract that uses the continue keyword to skip to the next iteration of a loop.

```  ✅ ```65.Write a contract that uses the return keyword to return a value from a function.

66.Create a contract that uses the throw keyword to throw an exception.

67.Write a contract that uses the try/catch syntax to handle exceptions.

68.Create a contract that uses the import keyword to import a contract from another file.

```  ✅ ```69.Write a contract that uses the pragma solidity ^0.8.0; directive to specify the Solidity compiler version.

```  ✅ ```70.Create a contract that uses the contract keyword to define a new contract.

71.Write a contract that uses a library to perform safe arithmetic operations.

72.Create a contract that uses a modifier to restrict function access to the contract owner.

73.Write a contract that uses an event to log the transfer of tokens.

74.Create a contract that uses a mapping and a dynamic array to store and iterate over a list of structs.

75.Write a contract that uses a constructor to initialize a token with a fixed supply and assign all tokens to the contract creator.

76.Create a contract that uses the fallback function to accept Ether and emit an event with the sender and the amount.

78.Write a contract that uses the receive function to accept Ether and emit an event with the sender and the amount.

79.Create a contract that uses the selfdestruct function to destroy the contract and send its balance to the contract owner.

80.Write a contract that uses the revert function to undo state changes if a condition is not met.

81.Create a contract that uses the require function to validate inputs and throw an error with a custom message if the inputs are invalid.

82.Write a contract that uses the assert function to check invariants and throw an error if an invariant is violated.

83.Create a contract that uses the keccak256 function to hash a value and the ecrecover function to verify a digital signature.

84.Write a contract that uses the block.timestamp property to implement a time-based condition.

85.Create a contract that uses the block.number property to implement a block-based condition.

86.Write a contract that uses the gasleft function to check the remaining gas and revert if it is too low.

87.Create a contract that uses the tx.origin property to check the original sender of the transaction and revert if it is not the contract owner.

88.Write a contract that uses the tx.gasprice property to check the gas price of the transaction and revert if it is too high.

89.Create a contract that uses the abi.encode function to ABI-encode values and the abi.decode function to ABI-decode values.

90.Write a contract that uses the address.balance property to check the balance of the contract and the address.transfer function to send Ether.

91.Create a contract that uses the address.call function to call a function on another contract and handle the return value.

92.Write a contract that uses the address.delegatecall function to delegate a call to another contract and handle the return value.

93.Create a contract that uses the address.staticcall function to make a read-only call to another contract and handle the return value.

94.Write a contract that uses the bytes.length property to check the length of a bytes array and the bytes.concat function to concatenate two bytes arrays.

95.Create a contract that uses the bytes32.byte property to get a specific byte in a bytes32 value and the bytes32.leftPadded and bytes32.rightPadded functions to pad a bytes32 value.

96.Write a contract that uses the int.min and int.max properties to check the range of an integer value.

97.Create a contract that uses the uint.min and uint.max properties to check the range of an unsigned integer value.

98.Write a contract that uses the array.push function to add an element to an array, the array.pop function to remove an element from an array, and the array.length property to get the length of an array.

99.Create a contract that uses the mapping[key] syntax to access a value in a mapping and a loop to iterate over the keys.

100.Write a contract that uses the for keyword to create a loop and the break keyword to exit the loop.

101.Create a contract that uses the if keyword to create a conditional statement and the else keyword to create an alternative branch.

102.Write a contract that uses the while keyword to create a loop and the continue keyword to skip to the next iteration.

103.Create a contract that uses the do keyword to create a loop and the return keyword to return a value from a function.

104.Write a contract that uses the throw keyword to throw an exception and the try/catch syntax to handle exceptions.

```  ✅ ```105.Create a contract that uses the import keyword to import a contract from another file and the is keyword to inherit from it.

106.Write a contract that uses the pragma solidity ^0.8.0; directive to specify the Solidity compiler version and the contract keyword to define a new contract.

```  ✅ ```107.Create a contract that uses the public, private, internal, and external keywords to specify function visibility.

```  ✅ ```108.Write a contract that uses the constant, pure, and view keywords to declare functions that do not modify the state.

109.Create a contract that uses the payable keyword to allow a function to receive Ether and the msg.value keyword to get the amount of Ether sent.

110.Write a contract that uses the abstract keyword to declare a contract that is not fully implemented and the interface keyword to declare a contract that only contains function signatures.

111.Create a contract that uses the override keyword to change the behavior of an inherited function and the virtual keyword to declare a function that can be overridden.

112.Write a contract that uses the super keyword to call a function in a parent contract and the this keyword to refer to the contract itself.

113.Create a contract that uses the new keyword to create a new contract and the delete keyword to reset a variable to its initial state.

114.Write a contract that uses the storage, memory, and calldata keywords to declare variables with different data locations.

115.Create a contract that uses the using keyword to attach library functions to a certain type and the library keyword to define a reusable piece of code.

116.Write a contract that uses the assembly keyword to write inline assembly code and handle low-level operations.

117.Create a contract that uses the msg.sender keyword to get the address of the person calling a function and the msg.data keyword to get the data sent with the call.

118.Write a contract that uses the block.coinbase property to get the current block miner’s address and the block.difficulty property to get the current block difficulty.

119.Create a contract that uses the abi.encodePacked function to ABI-encode values with packed encoding and the abi.encodeWithSignature function to ABI-encode values with a function signature.

120.Write a contract that uses the address.payable function to convert an address to a payable address and the address.code property to get the code at an address.

121.Create a contract that uses the bytes32.toHexString function to convert a bytes32 value to a hexadecimal string and the bytes32.toUint function to convert a bytes32 value to an unsigned integer.

