# solidityQuestions
This repo is to solve some random solidity question and submit there answers 

## QUESTIONS

1.Write a Solidity contract that stores a single number. Include a function to update this number.

2.Create a contract that stores an address. Include a function to update this address. 

3.Write a contract that stores a string. Include a function to update this string.

Create a contract that stores an array of numbers. Include functions to add and remove numbers from this array.

Write a contract that stores a mapping from addresses to numbers. Include functions to update this mapping.

Create a contract that includes a payable function. This function should update a stored number based on the amount of Ether sent.

Write a contract that emits an event. Include a function that triggers this event.

Create a contract that includes a modifier. Use this modifier in a function.

Write a contract that inherits from another contract. Include a function in the child contract that overrides a function in the parent contract.

Create a contract that interacts with another contract. Include a function in the first contract that calls a function in the second contract.

Write a contract that uses a struct to store information about a person (name, age, and address).

Create a contract that uses an enum to represent different states of a process.

Write a contract that includes a constructor function.

Create a contract that includes a fallback function.

Write a contract that uses the now keyword to get the current timestamp.

Create a contract that uses the msg.sender keyword to get the address of the person calling a function.

Write a contract that uses the msg.value keyword to get the amount of Ether sent with a function call.

Create a contract that uses the this keyword to refer to the contract itself.

Write a contract that uses the new keyword to create a new contract.

Create a contract that uses the delete keyword to reset a variable to its initial state.

Write a contract that uses the assert function to check invariants.

Create a contract that uses the require function to check inputs and conditions.

Write a contract that uses the revert function to revert state changes.

Create a contract that uses the keccak256 function to hash a value.

Write a contract that uses the ecrecover function to recover the address associated with a digital signature.

Create a contract that uses the selfdestruct function to destroy the contract and send its funds to an address.

Write a contract that uses the block.timestamp property to get the current block timestamp.

Create a contract that uses the block.number property to get the current block number.

Write a contract that uses the block.difficulty property to get the current block difficulty.

Create a contract that uses the block.coinbase property to get the current block minerâ€™s address.

Write a contract that uses the gasleft function to get the remaining gas.

Create a contract that uses the tx.origin property to get the original sender of the transaction.

Write a contract that uses the tx.gasprice property to get the gas price of the transaction.

Create a contract that uses the abi.encode function to ABI-encode values.

Write a contract that uses the abi.decode function to ABI-decode values.

Create a contract that uses the abi.encodePacked function to ABI-encode values with packed encoding.

Write a contract that uses the abi.encodeWithSignature function to ABI-encode values with a function signature.

Create a contract that uses the address.balance property to get the balance of an address.

Write a contract that uses the address.transfer function to send Ether to an address.

Create a contract that uses the address.call function to call a function on another contract.

Write a contract that uses the address.delegatecall function to delegate a call to another contract.

Create a contract that uses the address.staticcall function to make a read-only call to another contract.

Write a contract that uses the address.payable function to convert an address to a payable address.

Create a contract that uses the bytes.length property to get the length of a bytes array

Write a contract that uses the bytes.concat function to concatenate two bytes arrays.

Create a contract that uses the bytes32.byte property to get a specific byte in a bytes32 value.

Write a contract that uses the bytes32.leftPadded function to left-pad a bytes32 value.

Create a contract that uses the bytes32.rightPadded function to right-pad a bytes32 value.

Write a contract that uses the int.min property to get the minimum value of an integer type.

Create a contract that uses the int.max property to get the maximum value of an integer type.

Write a contract that uses the uint.min property to get the minimum value of an unsigned integer type.

Create a contract that uses the uint.max property to get the maximum value of an unsigned integer type.

Write a contract that uses the array.push function to add an element to an array.

Create a contract that uses the array.pop function to remove an element from an array.

Write a contract that uses the array.length property to get the length of an array.

Create a contract that uses the array[0] syntax to access an element in an array.

Write a contract that uses the mapping[key] syntax to access a value in a mapping.

Create a contract that uses the for keyword to create a loop.

Write a contract that uses the if keyword to create a conditional statement.

Create a contract that uses the else keyword to create an alternative branch in a conditional statement.

Write a contract that uses the while keyword to create a loop.

Create a contract that uses the do keyword to create a loop.

Write a contract that uses the break keyword to exit a loop.

Create a contract that uses the continue keyword to skip to the next iteration of a loop.

Write a contract that uses the return keyword to return a value from a function.

Create a contract that uses the throw keyword to throw an exception.

Write a contract that uses the try/catch syntax to handle exceptions.

Create a contract that uses the import keyword to import a contract from another file.

Write a contract that uses the pragma solidity ^0.8.0; directive to specify the Solidity compiler version.

Create a contract that uses the contract keyword to define a new contract.
