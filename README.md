# solidityQuestions
This repo is to solve some random solidity question and submit there answers 

### ```  ✅  question answered   ❌ pending ```

## QUESTIONS


```  ✅ ```1. Write a Solidity contract that stores a single number. Include a function to update this number.

```  ✅ ```2. Create a contract that stores an address. Include a function to update this address. 

```  ✅ ```3. Write a contract that stores a string. Include a function to update this string.  

```` ❌ ```4.Create a contract that stores an array of numbers. Include functions to add and remove numbers from this array.

5.Write a contract that stores a mapping from addresses to numbers. Include functions to update this mapping.

```  ✅ ```6.Create a contract that includes a payable function. This function should update a stored number based on the amount of Ether sent.

7.Write a contract that emits an event. Include a function that triggers this event.

```  ✅ ```8.Create a contract that includes a modifier. Use this modifier in a function.

9.Write a contract that inherits from another contract. Include a function in the child contract that overrides a function in the parent contract.

10.Create a contract that interacts with another contract. Include a function in the first contract that calls a function in the second contract.

11.Write a contract that uses a struct to store information about a person (name, age, and address).

12.Create a contract that uses an enum to represent different states of a process.

13.Write a contract that includes a constructor function.

14.Create a contract that includes a fallback function.

15.Write a contract that uses the now keyword to get the current timestamp.

16.Create a contract that uses the msg.sender keyword to get the address of the person calling a function.

17.Write a contract that uses the msg.value keyword to get the amount of Ether sent with a function call.

18.Create a contract that uses the this keyword to refer to the contract itself.

19.Write a contract that uses the new keyword to create a new contract.

20.Create a contract that uses the delete keyword to reset a variable to its initial state.

21.Write a contract that uses the assert function to check invariants.

22.Create a contract that uses the require function to check inputs and conditions.

23.Write a contract that uses the revert function to revert state changes.

24.Create a contract that uses the keccak256 function to hash a value.

25.Write a contract that uses the ecrecover function to recover the address associated with a digital signature.

26.Create a contract that uses the selfdestruct function to destroy the contract and send its funds to an address.

27.Write a contract that uses the block.timestamp property to get the current block timestamp.

28.Create a contract that uses the block.number property to get the current block number.

29.Write a contract that uses the block.difficulty property to get the current block difficulty.

30.Create a contract that uses the block.coinbase property to get the current block miner’s address.

31.Write a contract that uses the gasleft function to get the remaining gas.

32.Create a contract that uses the tx.origin property to get the original sender of the transaction.

33.Write a contract that uses the tx.gasprice property to get the gas price of the transaction.

34.Create a contract that uses the abi.encode function to ABI-encode values.

35.Write a contract that uses the abi.decode function to ABI-decode values.

36.Create a contract that uses the abi.encodePacked function to ABI-encode values with packed encoding.

37.Write a contract that uses the abi.encodeWithSignature function to ABI-encode values with a function signature.

38.Create a contract that uses the address.balance property to get the balance of an address.

39.Write a contract that uses the address.transfer function to send Ether to an address.

40.Create a contract that uses the address.call function to call a function on another contract.

41.Write a contract that uses the address.delegatecall function to delegate a call to another contract.

42.Create a contract that uses the address.staticcall function to make a read-only call to another contract.

43.Write a contract that uses the address.payable function to convert an address to a payable address.

44.Create a contract that uses the bytes.length property to get the length of a bytes array

45.Write a contract that uses the bytes.concat function to concatenate two bytes arrays.

46.Create a contract that uses the bytes32.byte property to get a specific byte in a bytes32 value.

47.Write a contract that uses the bytes32.leftPadded function to left-pad a bytes32 value.

48.Create a contract that uses the bytes32.rightPadded function to right-pad a bytes32 value.

49.Write a contract that uses the int.min property to get the minimum value of an integer type.

50.Create a contract that uses the int.max property to get the maximum value of an integer type.

51.Write a contract that uses the uint.min property to get the minimum value of an unsigned integer type.

52.Create a contract that uses the uint.max property to get the maximum value of an unsigned integer type.

53.Write a contract that uses the array.push function to add an element to an array.

54.Create a contract that uses the array.pop function to remove an element from an array.

55.Write a contract that uses the array.length property to get the length of an array.

56.Create a contract that uses the array[0] syntax to access an element in an array.

57.Write a contract that uses the mapping[key] syntax to access a value in a mapping.

58.Create a contract that uses the for keyword to create a loop.

59.Write a contract that uses the if keyword to create a conditional statement.

60.Create a contract that uses the else keyword to create an alternative branch in a conditional statement.

61.Write a contract that uses the while keyword to create a loop.

62.Create a contract that uses the do keyword to create a loop.

63.Write a contract that uses the break keyword to exit a loop.

64.Create a contract that uses the continue keyword to skip to the next iteration of a loop.

65.Write a contract that uses the return keyword to return a value from a function.

66.Create a contract that uses the throw keyword to throw an exception.

67.Write a contract that uses the try/catch syntax to handle exceptions.

Create a contract that uses the import keyword to import a contract from another file.

Write a contract that uses the pragma solidity ^0.8.0; directive to specify the Solidity compiler version.

Create a contract that uses the contract keyword to define a new contract.
